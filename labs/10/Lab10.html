<!DOCTYPE html>
<!-- saved from url=(0057)http://www.cs.sfu.ca/CourseCentral/125/bbart/1/index.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
    <meta charset="utf-8">
    <title>CMPT127 Lab 10</title>
    
     <!-- Please don't change internal links and refs to absolute paths -->
    <link rel="stylesheet" href="../css/style.css">
	
	<!--<link rel="icon" href="../favicon.ico" type="image/x-icon"> NOT FOUND -->
	<link rel="icon" href="../img/favicon.ico" type="image/x-icon"> 
    	
	<!-- Code syntax highlighting -->
	<!--<script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"> NOT FOUND -->
	<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>	

    <!-- force printing a line number in every line when prettyprinting -->
    <style>
        .prettyprint ol.linenums > li { list-style-type: decimal; }
    </style>
</head>

<!--
Minor changes: Anne Lavergne 2017 + 2019
-->

<body>


<div class="lab">
<h1>Lab 10: C++ classes</h1>

<h4>classes and objects, constructors and destructors, refactoring</h4>


<div id="floatingCornerLeft">
<a href="http://books.google.ca/books?id=RFJiAgAACAAJ&dq=%22Computer+lieben+Frauen&hl=en&sa=X&ei=H9SoUuCrBI_YoASa2oCADQ&ved=0CEcQ6AEwAA" target="_blank"><img src="../img/balloon0.jpg" height="150"></a>
</div>

<div id="floatingCornerRight">
  <a href="http://books.google.ca/books?id=RFJiAgAACAAJ&dq=%22Computer+lieben+Frauen&hl=en&sa=X&ei=H9SoUuCrBI_YoASa2oCADQ&ved=0CEcQ6AEwAA" target="_blank"><img src="../img/balloon1.jpg" height="150"></a>
</div>


</p><h3>Goals</h3>

<p>After this lab you will be able to

<ol>
<li>Use classes in place of structs. 
<li>Write constructors and destructors for classes.
<li>Use two-dimensional arrays.
<li>Refactor code.
</ol>

<p>Apart from teaching you to use classes and 2d-arrays, this lab is
designed to have you work repeatedly on the same code. By now you
should be reading and writing code much more quickly than at the
beginning of the course. You should also be using your text editor more
expertly, for example using search-and-replace, moving around quickly
in the file, cutting and pasting lines using keystrokes, etc.  You
will spend many hours in your text editor during your degree and
beyond: you should master it.

<p>Refactoring code (Task 3) is an activity that exercises your editor kung-fu, and will not take too long if you use the editor well.

<h3>Setup</h3>

<div class="steps">

<p>Note that these instructions no longer include all steps. You should know how to do these things by now. If in doubt, refer to
previous lab instructions.</p>

<p>In the terminal:
<ol>
<li>Move into your local repo (making it your "working directory").</li>
<li>Download the <a href="10.zip" target="_blank">new material</a> for Lab 10.</li>
<li>Expand it into your working directory. This will create the directory '10' containing the files you need.
<li>Add the new directory to your Git repo with 
<pre>$ git add 10</pre>
</ol>
<br>
</div>



<h1>Introducing C++</h1>

<p>C++ extends the C language with support for <i>classes</i> to support <a href="http://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank">Object-Oriented Programming</a>, and <i>templates</i> 
to support <a href="http://en.wikipedia.org/wiki/Generic_programming" target="_blank">Generic Programming</a>. This week we will look at classes, but first a summary of the workflow changes you need to use C++.

<ol>
<li>C++ source code files have the conventional suffix ".cpp" or ".cc", instead of C's ".c".
<li>C++ header files <i>may</i> have the suffix ".hpp" or ".hh", or stick with C's ".h". We will use ".hpp" to make it clear when we have a C++ header.
<li>The GNU C++ compiler program is called "g++", instead of "gcc". 
</ol>

<p>Note that the intructions below do not provide compile commands for you to cut'n'paste. You will need to read the notes above and construct your own compile commands.

<h3>A C++ primer for C programmers</h3>

<a href="http://homes.cs.washington.edu/~tom/c++example/c++.pdf" target="_blank">Here is a very good and concise introduction to C++ for C programmers.</a> 
by <a href="http://www.cs.washington.edu/people/faculty/tom/" target="_blank">Prof. Tom Anderson of the University of Washington</a>.

<p>Prof. Anderson has strong opinions about the useful and less-useful parts of C++, and draws your attention to the most important parts in less than 12 pages. The document is dated in some ways, but most of the advice is excellent. 

<div class="steps">
<p>Things to do:
<ol>
<li>Read Sections 1 through 3 carefully: they will help with your tasks this week.
<li>Read Sections 4 and 5 at your leisure, and remember that opinions vary wildly on this subject, and things change over time. 
<li>Note that the Standard Template Library (STL) is now mature and supported by most compilers, and you can and should use it with confidence. 
<!--We will show you the basics of the STL in a later lab.-->
</ol>
</div>

<p>Note that you really are expected to read the document, and the following instructions may not be enough by themselves to help you solve the tasks. Another goal of this lab (and the class) is to encourage you to read around your subjects and feel personal responsibility for learning. 

<p style="background: #F00;">
<br>
<b>** STOP ** READ THE PRIMER DOCUMENT BEFORE CONTINUING **</b>
<br>
<br>

<div class ="task">
<h2>Task 1: Image class</h2>

<p>We will develop a C++ program, using ideas familiar from previous labs plus new syntax for creating classes. 


<h3>Requirements</h3>
<div class="req">
<ol>
<li>Read the Primer (see above) and the Guide section on classes (see below), constructors and destructors below.
<li>Write a new C++ source file "image.cpp" that contains a complete implementation of the Image class declared in the provided C++ header file "image.hpp".
<li>Your file must include "image.hpp" without any modifications.
<li>Write your own main() function for testing your class, but put it in another source file: do not define main() in "image.cpp" as this will interfere with the grading robot.
</ol>

</div>

<h3>Submission</h3>

<p>Add and commit the single file "image.cpp" to your repo.


<h2>Guide</h2>

<h3>C to C++</h3>

<p>Here is an interface definition for an image data type in C, extended from the one we developed in an earlier lab:

<pre class="prettyprint">
typedef struct image { 
  unsigned int cols;
  unsigned int rows;
  uint8_t* pixels;
} img_t;

/* Returns an img_t structure containing 0x0 pixels. */
img_t img_create( void );

/* Frees all memory allocated for img */
void img_destroy( img_t* img );

/* Changes the size of an image, allocating memory as necessary, and
   setting all pixels to fillcolour. Returns 0 on success, or a non-zero error code.*/ 
int img_resize( img_t* img, unsigned int width,  unsigned int height, uint8_t fillcolour );

/* Sets the colour of the pixel at (x,y) to colour. Returns 0 on success, else a non-zero 
   error code. If (x,y) is not a valid pixel, the call fails and the image does not change. */
int img_set_pixel( img_t* img, unsigned int x, unsigned int y, uint8_t colour );

/* Gets the colour of the pixel at (x,y) and stores at the address pointed to by colour. 
   Returns 0 on success, else a non-zero error code. */
int img_get_pixel( img_t* img, unsigned int x, unsigned int y, uint8_t* colourp );
</pre>

<p>We could use these definitions as-is in a C++ program, since C is almost a subset of C++. However, an implementation in C++ style would have the following differences:

<ol>
<li>The structure would be a class 
<li>The functions operating on image structures would be methods of the image class, and would not need the "img_" prefix.
<li>Image class methods do no need a pointer to the image data structure, since they automatically have a <code>this</code> pointer-to-the-object-on-which-the-method-was-called.
<li>The fields of the struct would not be accessible from outside the class: an image could only be modified using its methods. 
<li>img_create() would be a constructor
<li>img_destroy() would be a destructor
</ol>

<p>Here is the C++ version:

<pre class="prettyprint">
class Image {

private:
  unsigned int cols;
  unsigned int rows;
  uint8_t* pixels;

public:
  /* Constructs an image of 0x0 pixels. */
  Image();

  /* Frees all memory allocated for img */
  ~Image();

  /* Changes the size of an image, allocating memory as necessary, and
     setting all pixels to fillcolour. Returns 0 on success, or a non-zero error code.*/ 
  int resize( unsigned int width,  unsigned int height, uint8_t fillcolour );

   /* Sets the colour of the pixel at (x,y) to colour. Returns 0 on success, else a non-zero 
      error code. If (x,y) is not a valid pixel, the call fails and the image does not change.*/
  int set_pixel( unsigned int x, unsigned int y, uint8_t colour );

   /* Gets the colour of the pixel at (x,y) and stores at the address pointed to 
      by colourp. Returns 0 on success, else a non-zero error code. */
  int get_pixel( unsigned int x, unsigned int y, uint8_t* colourp );
};
</pre>


<p>Here they are again without the comments so the functional parts are easier to compare:

<p>C:

<pre class="prettyprint">
typedef struct image { 
  unsigned int cols;
  unsigned int rows;
  uint8_t* pixels;
} img_t;

img_t  img_create( void );
void   img_destroy( img_t* img );
int    img_resize( img_t* img, unsigned int width, unsigned int height, uint8_t fillcolour );
int    img_set_pixel( img_t* img, unsigned int x, unsigned int y, uint8_t colour );
int    img_get_pixel( img_t* img, unsigned int x, unsigned int y, uint8_t* colourp );
</pre>

<p>C++:

<pre class="prettyprint">
class Image {
private:
  unsigned int cols;
  unsigned int rows;
  uint8_t* pixels;

public:
  Image();
  ~Image();
  int resize( unsigned int width,  unsigned int height, uint8_t fillcolour );
  int set_pixel( unsigned int x, unsigned int y, uint8_t colour );
  int get_pixel( unsigned int x, unsigned int y, uint8_t* colourp );
};

</pre>

<p>Examples of usage, first in C:

<pre  class="prettyprint">
 img_t img = img_create();

 if( img_resize( &img, 640, 480, 0 ) != 0 )
 { 
   exit(1); // quit 
 }
  
 for( int i=0; i<100; i++ )
 {
    img_set_pixel( &img, 
                   rand() % 640, 
                   rand() % 480, 
	           rand() % 256 );
 }		       

 // output the image here somehow
 // ...		      

 img_destroy( &img ); // must not forget this
</pre>

<p>then C++:
<pre  class="prettyprint">
 Image img;
 
 if( img.resize( 640, 480, 0 ) != 0 )
 { 
   exit(1); // quit 
 }
  
 for( int i=0; i<100; i++ )
 {
    img.set_pixel( rand() % 640, 
                   rand() % 480, 
                   rand() % 256 );
 }		       

 // output the image here somehow
 // ...		      

 // img destructor is called when img goes out of scope.
</pre>


<h3>Constructors and destructors</h3>

<p>We have consistently used X_create() and X_destroy() functions when dealing with structures. 
This is a very common <a href="http://en.wikipedia.org/wiki/Software_design_pattern" target="_blank">design pattern</a> for doing allocation and deallocation cleanly. This technique became so common in C and is so useful that it is built in to C++ in the form of <b>constructors</b> and <b>destructors</b>. 

<h4>Constructors</h4>

<p>Whenever an instance of a class (an <b>object</b>) is created, its constructor is automatically called. You put initialization code inside the constructor, so that all instances have their data members initialized properly before they can be used.

<p>Constructors have the same name as their class, and they have no return type or value.

<p>When a constructor is called, the constructors of all the class's data members are called first automatically, so they are ready for use in the constructor. There is a special syntax for giving arguments to these data member constructors, called the <b>initialization list</b>: 

<pre class="prettyprint">
// contains the class declaration for Image
#include "image.hpp"

Image::Image()
  : cols(0),   // initialization list 
    rows(0), 
    pixels(NULL) 
{
   // No work to do in constructor body in this example: 
   // the intialization list took care of it. 
   // All  members now have safe initial values.
}
    
</pre>

<P>A weak point of the C++ design is that handling errors in constructors is quite complicated, since they have no return value. It is a good idea to avoid doing anything in a constructor that could fail, for example any system call or memory allocation. This is why in our example we construct only 0x0 pixel images, and do our pixel allocation in Image::resize(); If any <code>new</code> fails, your program will be terminated immediately. You can change this behaviour using <b>exceptions</b> but that is beyond the scope of this class. 
(Some people think exceptions are a Bad Idea, for example 
<a href="https://google.github.io/styleguide/cppguide.html#Exceptions" target="_blank">Google does not allow them in any C++ code</a>).

<h4>Destructors</h4>
<p>Whenever an object is destroyed, either by going out of scope or when delete is called on its address, the destructor is automatically called. You put memory deallocation and clean-up code in the destructor so you can not forget to recycle resources when you are finished with an object. After the destructor finishes, the destructors of any data members are called.

<p>Destructors have the same name as their class, prefixed with a '~' and they have no return type or value.

<pre class="prettyprint">
// contains the class declaration for Image
#include "image.hpp"

Image::~Image()
{
   // free everything that could have been allocated inside this object
   if( pixels != NULL ) 
   {
      delete[] pixels; 
   }
}
    
</pre>


<h4>Creating and destroying objects</h4>

<p>Objects can be created on the stack, just by declaring them, and their methods called using dot syntax:

<pre class="prettyprint">
Image img;
img.resize( 100, 100, 255 ); // white square image

</pre>

<p>When a stack-allocated object goes out of scope, its destructor is called automatically. 

<p>Objects can also be allocated on the heap using the <code>new</code> keyword followed by the class name. <code>new</code> replaces <code>malloc()</code> for most purposes in C++. <code>new</code> returns a pointer to an instance of the class, so members and methods are accessed using arrow syntax. 
<p>Unfortunately, keeping track of pointers to destruct objects automatically is quite costly, so heap-allocated objects must be destroyed manually:

<pre class="prettyprint">
Image* img = new Image;
img->resize( 100, 100, 255 ); // white square image
// (use image, then when done )
delete img;
</pre>

<p>Other languages such as Java and C# can keep track of heap allocations and save you the trouble of deleting things. 
This <a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" target="_blank">garbage collection</a> process can be very good for code robustness, but slows things down a bit.

<p>In C++ the basic memory sanitation strategy is (i) write thorough
destructors; and (ii) use stack variables whenever possible. Remember
your stack is small so big things go on the heap. A good approach is to
have a small stack-allocated wrapper/header object for each of your
heap-allocated big things, so that when the wrapper object goes
out of scope its destructor cleans up properly. The Image class follows this pattern.

<h4>Default constructors</h4>

<p>A constructor that takes no arguments is called a <b>default
constructor</b>. If you do not specify any constructor for your class,
a default constructor is generated automatically that simply calls the
constructors of all data members of the class. The built-in types (int, float, etc) 
have default constructors that allocate space only: their values are left uninitialized, like in C. 

<h4>Creating arrays of objects</h4>

<p>New and delete have convenient array forms, which can be used with built-in types and any object that has a default constructor.

<pre class="prettyprint">
int* arr = new int[100]; 
// (use int array, then when done)
delete[] arr;
</pre>

<p>For objects, the default constructor is called for every item in the array. Similarly <code>delete[]</code> calls the destructor on each item in the array before freeing the entire array. 

<!--
<p>For objects, the default constructor is called for the first item in the array, and the resulting object is copied into all the remaining array elements.
-->

<pre class="prettyprint">
Bubble* bubbles = new Bubble[100]; // produces 100 bubbles, all the same
// (use bubble array, then when done)
delete[] bubbles;
</pre>

<h4>Teach the controversy</h4>

<p>Not everyone is a fan of <code>new</code> and <code>delete</code>, and <a href="http://www.scs.stanford.edu/~dm/home/papers/c++-new.html" target="_blank"> this "rant" by Stanford professor David Mazières discusses some of the issues that bother people</a>. Following the author's argument will test and boost your understanding of how they work. 

<h4>Methods</h4>

<p>Class methods are like normal functions, but they can only be
called through an object of the right type. A key advantage of this is
that you can not pass in the wrong kind of pointer, or a null pointer.

<p>Methods are defined (in .cpp file) by prefixing the method name with the name of the class:

<pre class="prettyprint">
#include "image.hpp"

int Image::resize( unsigned int width, unsigned int height, uint8_t fillcolour )
{
   // do the work here
   // ...
   return 0;
}


int Image::set_pixel( unsigned int x, unsigned int y, uint8_t colour )
{
   // do the work here
   // ...
   return 0;
}

// (etc)
</pre>

<p>Inside a class's methods, all the <b>members</b> of the class are available using just their names:

<pre class="prettyprint">
int Image::set_pixel( unsigned int x, unsigned int y, uint8_t colour )
{
  // x, y, and colour are local variables
  // pixels and cols are members of this object
  pixels[ y*cols + x ] = colour; 
  return 0;
}
</pre>

<p>In case a method needs to know which object it was called on, a pointer called <code>this</code> always exists. <code>this</code> points to the object on which the method was called. So this code is identical to the above:

<pre class="prettyprint">
int Image::set_pixel( unsigned int x, unsigned int y, uint8_t colour )
{
  // x, y, and colour are local variables
  // pixels and cols are members of this object
  // so can be accessed through the 'this' pointer
  this->pixels[ y * this->cols + x ] = colour; 
  return 0;
}
</pre>

<p>Inside an object's methods, its other methods are also available using their name alone, or through the <code>this</code> pointer:

<pre class="prettyprint">
void Image::set_grey_all_over( void )
{
  for( int y=0; y&lt;rows; y++ ) // this->rows
    for( int x=0; x&lt;cols; x++ ) // this->cols
      set_pixel( x, y, 128 ); // this->set_pixel()
}
</pre>

<p>Once an object is constructed, its data members and methods are accessed using dot or arrow syntax, just like structures, except that now we can access an object's methods to operate on it:

<pre class="prettyprint">
Image i();
i.resize( 640, 480, 0 );
i.set_pixel( 100, 100, 255 );

Image* j = new Image();
j->resize( 640, 480, 0 );
j->set_pixel( 100, 100, 255 );
</pre>
</div>


<div class ="task">
<h2>Task 2: Save & Load</h2>

<p>Extend your Image class by adding save() and load() methods. The file format is up to you. It can be text or binary, as long as the load() loads the save()'d format correctly.

<h3>Requirements</h3>
<div class="req">
<ol>
<li>Write a new C++ source file "image2.cpp" that contains a complete implementation of the Image class declared in the provided C++ header file "image2.hpp".
<li>Your file must include "image2.hpp" without any modifications.
<li>Write your own main() function for testing your class, but put it in another source file: do not define main() in "image2.cpp" as this will interfere with the grading robot.
</ol>

</div>

<h3>Submission</h3>

<p>Add and commit the single file "image2.cpp" to your repo.

<h3>Guide</h3>
<p>See Lab 6 for file I/O tutorial and examples.
</div>

<div class ="task">
<h2>Task 3: Alternate implementation using 2D arrays</h2>

<p>Change the internal representation of the image in your Image
class, without changing the external interface.

<p>We will use a multi-dimensional array to store pixels instead of
the one-dimensional pixel array we have used so far.

<p>The process of revising your implementation without changing the interface or external behaviour is called 
<a href="http://en.wikipedia.org/wiki/Code_refactoring" target="_blank">refactoring</a> and can be very important for keeping code maintainable, particularly after a period of adding a lot of features or bugfixes. Tidying up a messy implementation before it gets too complicated for mortals to understand is useful work. On the other hand you should resist tinkering for the sake of it: you risk introducing bugs.


<h3>Requirements</h3>
<div class="req">

<p>The supplied file "image3.hpp" differs from "image2.hpp" only in
that it declares the private pixel data pointer to be of type <code>uint8_t**</code>. You must reimplement the Image class using a 2D array. This will make memory allocation code a little more complex (see the Guide below), but make accessing pixels easier and arguably make the code more readable. Certain image operations you implemented in an earlier lab could be faster or easier using 2D arrays: you do not have to implement them here, but you should think about which ones would benefit.
<ol>
<li>Write a new C++ source file "image3.cpp" that contains a complete implementation of the Image class declared in the provided C++ header file "image3.hpp".
<li>Your file must include "image3.hpp" without any modifications.
<li>Note that since the interface of the class (i.e. the public methods) did not change, you can use the same main() program to test it as for the previous tasks. Make sure no main() function exists in "image3.cpp".
</ol>

</div>

<h3>Caution</h3>
<p>save() and load() need some careful thought. Favour correctness over speed, but try not to make too many system calls: they are slow.

<h3>Submission</h3>

<p>Add and commit the single file "image3.cpp" to your repo.

<h3>Guide</h3>

<P>C and C++ support multi-dimensional arrays. The syntax is very
simple but the underlying model is a little complex. Consider these
arrays, where a 2D array is declared and used in the way you might
guess by extrapolating from the 1D case:

<pre class="prettyprint">
int A[16]; // 1D array of 16 elements
int B[4][4]; // 2D array of 4x4 elements

// sets every element in A
for( int a=0; a<16; a++ )
{
   A[a] = 99;
}

// sets every element in B
for( int y=0; y<4; y++ )
{
  for( int x=0; x<4; x++ )
  {
     B[y][x] = 99;
  }
}
</pre>

<p>The memory layout for these arrays is quite different, as shown in the figure:

<table
<tr><td>
<img src="../img/Lab10/1darray.png">
<td>
<img src="../img/Lab10/2darray.png">
</table>

<p>'A' is of type array-of-int. 'B' is of type array-of-array-of-int. You can see that there is some overhead in using the 2D array, as
we require more memory space and a two-step lookup to find the integer
of interest. 

<h4>More dimensions</h4>

<p>The array declaration and access syntax works for arbitrary numbers of dimensions:

<pre class="prettyprint">
int C[3][3][3]; // 3D array of 9 ints
int D[20][5][10][4]; // 4D array of 20*5*10*4 ints

C[0][0][0] = 99;
D[101][2][1][0] = 99;
</pre>

<P>In practice, arrays of more than 3 dimensions are rarely used.


<h3>Building 2D arrays on the heap</h3>

<p>The examples above show multi-dimensional arrays allocated on the stack. They can also be allocated manually on the heap. This example builds arrays A and B on the heap (omitting error checking) in C:

<pre class="prettyprint">
int* A = malloc( 16 * sizeof(int) );

int** B = malloc( 4 * sizeof(int*) );
for( int i=0; i<4; i++ )
{
  B[i] = malloc( 4 * sizeof(int) );
}
</pre>

<p>This results in the same memory layout picture as above, except that all the arrays are in the heap: only pointers A and B are on the stack.

<p>The same thing in  C++ style using <code>new</code>:
<pre class="prettyprint">
int* A = new int[16];

int** B = new int*[4];
for( int i=0; i<4; i++ )
{
  B[i] = new int[4];
}
</pre>

<p>While this creation process is a bit laborious, accessing these arrays once created is simple and almost as fast as 1D arrays, so 2D arrays do get used quite a lot in practice.

<p>When multi-dimensional arrays are built up manually in this way,
you can cheaply reorder the higher dimensions of the array (e.g. 
B[y]) by swapping the pointers they contain, without touching the
contents of the lower dimensions (e.g. B[*][x]). If the elements
stored in the lowest dimension are numerous and/or large, this can
make a big difference in performance.
</div>
</div>
<hr>
<div class="labends">
Lab 10 complete. <a href="../../">Back to the course web page</a>.
</div>
</body>
</html>
<!--

/* Saves the image in the file filename. In a format that can be loaded by img_load().
   Returns 0 on success, else a non-zero error code. */
int img_save( img_t* img, char* filename );

/* Loads a new image structure from the file filename. In a format that was saved by img_save().
   Returns a pointer to an image on success, or NULL on error. */
img_t* img_load( char* filename );


   /* Saves the image in the file filename. In a format that can be loaded by img_load().
      Returns 0 on success, else a non-zero error code. */
   int save( char* filename );

   /* note: load() is missing for now */

  int save( char* filename );
  // load() missing for now

img_t* img_load( char* filename );

-->