<!DOCTYPE html>
<!-- saved from url=(0057)http://www.cs.sfu.ca/CourseCentral/125/bbart/1/index.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
    <meta charset="utf-8">
    <title>CMPT127 Lab 6</title>

     <!-- Please don't change internal links and refs to absolute paths -->
    <link rel="stylesheet" href="../css/style.css">

	<!--<link rel="icon" href="../favicon.ico" type="image/x-icon"> NOT FOUND -->
	<link rel="icon" href="../img/favicon.ico" type="image/x-icon">
    
    <!-- Code syntax highlighting -->
	<!--<script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"> NOT FOUND -->
	<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

    <!-- force printing a line number in every line when prettyprinting -->
    <style>
        .prettyprint ol.linenums > li { list-style-type: decimal; }
    </style>
</head>

<!--
Minor changes: Anne Lavergne 2017 + 2019
-->

<body>


<div class="lab">
<h1>Lab 6: File I/O</h1>

<h4><tt>external data representation; fopen(), fclose(), fread()</tt> and<tt> fwrite(), struct</tt> practice </h4>


<div id="floatingCornerLeft">
<a href="http://books.google.ca/books?id=RFJiAgAACAAJ&dq=%22Computer+lieben+Frauen&hl=en&sa=X&ei=H9SoUuCrBI_YoASa2oCADQ&ved=0CEcQ6AEwAA" target="_blank"><img src="../img/balloon0.jpg" height="150"></a>
</div>

<div id="floatingCornerRight">
<a href="http://books.google.ca/books?id=RFJiAgAACAAJ&dq=%22Computer+lieben+Frauen&hl=en&sa=X&ei=H9SoUuCrBI_YoASa2oCADQ&ved=0CEcQ6AEwAA" target="_blank"><img src="../img/balloon1.jpg" height="150"></a>
</div>


</p><h3>Goals</h3>
<p>After this lab you will be able to

<ol>
<li>Explain what XDR is, and how it relates to files.
<li>Open files with <tt>fopen()</tt> with correct usage mode, and <tt>fclose()</tt> them.
<li>Handle error codes returned from the relevant system calls.
<li>Read and write to files with <tt>fread()</tt> and <tt>fwrite()</tt> using simple arrays and structs.
</ol>


<h2>Setup</h2>
<div class="steps">
<p>In the terminal:
<ol>
	<li>From your local repo, create and 'git add' the new directory '6', then make '6' 
your working directory.</li>
	<li>Fetch the header file <a href="intarr.h" target="_blank">intarr.h</a>. <mark>This is a different 
<tt>intarr.h</tt> file than the one we fetched in Lab 5.</mark> It contains all the Lab 5 tasks (which you
have already done) as well as the Lab 6 tasks (which you are to do in this lab).</li>
<br>
</ol>
</div>


<h2>External Data Representation using Files</h2>

<p>A program's working memory of stack and heap data structures (i.e., data structures to which memory from the stack memory segment or the heap memory segment 
has been allocated) only exists while the program is running. To store data between runs, and to capture output, we can use the <i>filesystem</i>. 
The filesystem is a service provided by the operating system (OS) that provides <i>files</i> to your programs. A file is like a named array of bytes, and once created a file will persist until deleted, even when the computer is turned off. 

<p>You are familiar with files: text files like C sourcecode; sound files like MP3s; executable files like your compiled programs. At the filesystem abstraction level, these are all the same thing: just a contiguous sequence of bytes. The interpretation of these bytes is up to your program. 

<p>Files are a common special case of the general problem of storing data outside a running program. In general this is called <b>External Data Representation (XDR)</b>. Other examples of XDR occur when using databases or networking. 


<p>Files are identified by a <a href="http://en.wikipedia.org/wiki/Path_(computing)" target="_blank"><i>path</i></a>, which is a generalization of a 
<a href="http://en.wikipedia.org/wiki/Filename" target="_blank"><i>filename</i></a> and can be any of:

<ul>
<li>a simple filename, e.g. "hadfield.png". This is often used when we are "manipulating" a file located in the current directory. For example, in Lab 3, we issued 
the command 
<pre>$ ./test hadfield.png</pre>
at the command line. We were able to do so because our executable file <code>test</code> as well as our test file <code>hadfield.png</code> were both 
located in our current directory. </li>
<li>a <i>relative path</i> that specifies a path (location) in the filesystem's directory structure relative to the current working directory, 
e.g. "students/bsimpson/reportcard.pdf". This is often used when the path to a file can be specified starting from our current directory. 
For example, the desired file can be located either in a "parent" directory, i.e., a directory "above" the current directory, or in a directory "below"
 the current directory.</li>
<li>an <i>absolute path</i> that begins with a '/' (which signifies the "root" directory) and fully specifies a location in the directory structure, 
e.g. "/home/vader/projects/deathstar.dxf". This is used when the path to a file (location of a file) cannot be specified using the first two ways.</li>
</ul>


The programmer's interface to the filesystem is quite basic, with most of the work done with four abstract operations:

<ul>
<li><p>OPEN( path, mode ): opens a file (described by "path") for reading and/or writing, possibly creating a new file if file (i.e, "path") does not exist. These options are defined by the mode. Returns an identifier that the other functions use to identify an open file. 

The file has a length in bytes, which is initially zero for a new file, and a <i>current read/write position</i> which is an index into the bytes of the file at which read and write operations will do their work. After OPEN() the initial read/write position is either at the beginning or end of the file depending on the mode.

<li><p>WRITE( ID,  source, length ): writes length bytes from source into the file, starting from the current read/write position and overwriting anything already there. The length of the file will increase automatically if necessary. When the write has finished, the current read/write position is set to one beyond the data written.

<li><p>READ( ID, dest, length ): reads length bytes from the file into dest. When the read is finished, the current read/write position is set to one beyond the data read.

<li><p>CLOSE( ID ): closes the file, indicating to the OS that we have finished using it.  

</ul>

A less-used fifth operation, SEEK(), allows you to set the read/write position directly without reading or writing.

<p>Almost every programming language supports a version of this interface. You may recognize it from Python. For the C programmer, this interface is provided by these four <i>system calls</i> defined in <tt>stdio.h</tt>:

<pre class="prettyprint">FILE * fopen( const char * filename, 
              const char * mode);

size_t fwrite( const void * ptr, 
               size_t size, 
               size_t nitems, 
               FILE * stream);

size_t fread( void * ptr,
              size_t size, 
              size_t nitems, 
              FILE * stream);

int fclose( FILE *stream);
</pre>

<p>These calls closely match their abstract versions, except that read and write have a convenient extension that makes it easy to work with structs (see example code above). 
The following links give the specifications of each of these functions according to the 
<a  href="http://pubs.opengroup.org/onlinepubs/009695399/frontmatter/preface.html" target="_blank">Open Group standard</a>:

<ul>
<li><p>
<!--<a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/fopen.html" target="_blank"><tt>fopen()</tt></a>-->
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html" target="_blank"><tt>fopen()</tt></a>

<li><p>
<!--<a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/fwrite.html" target="_blank"><tt>fwrite()</tt></a>-->
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fwrite.html" target="_blank"><tt>fwrite()</tt></a>

<li><p>
<!--<a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/fread.html" target="_blank"><tt>fread()</tt></a>-->
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fread.html" target="_blank"><tt>fread()</tt></a>

<li><p>
<!--<a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/fclose.html" target="_blank"><tt>fclose()</tt></a>-->
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fclose.html" target="_blank"><tt>fclose()</tt></a>

</ul>

<p>Documentation is also available as man pages on your local computer. The advantages of the Open Group specifications are that they are sometimes better written, cover only the functionality supported by all standard implementations and  often contain examples. The man pages will contain details that are specific to your local OS. 

<p> You should get used to reading documentation in these forms.

<p>Unless you have a good reason, stick to the standard interfaces. This will make it easier (i) to port your code to another OS; and (ii) to find another programmer who can understand it. Also, new versions of OS are more likely to implement the standard than to retain their previous quirks.


<h4>A note on interface design</h4>

<P> These functions are a masterpiece of interface
design. <tt>fopen()</tt> has the most complex functionality, but a
very simple interface. <tt>fwrite()</tt> and <tt>fread()</tt> have
the <i>same</i> interface to opposite functionality. Your calls to
read and write look exactly the same, which makes it
easy to write them correctly. 

<h4>Useful extras</h4>

You may find these useful:

<ul>
<li><p>
<!--<a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/fseek.html" target="_blank"><tt>fseek()</tt></a> : repositions the current read/write location.-->
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fseek.html" target="_blank"><tt>fseek()</tt></a> : repositions the current read/write location.

<li><p>
<!--<a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/feof.html" target="_blank"><tt>feof()</tt></a> : tells you if the end-of-file is reached.-->
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/feof.html" target="_blank"><tt>feof()</tt></a> : tells you if the end-of-file is reached.

<li><p>
<!--<a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/ftell.html" target="_blank"><tt>ftell()</tt></a> : returns the current read/write location.-->
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/ftell.html" target="_blank"><tt>ftell()</tt></a> : returns the current read/write location.

<li><p>
<!--<a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/ftruncate.html" target="_blank"><tt>ftruncate()</tt></a> : truncate a file to a specified length.-->
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/ftruncate.html" target="_blank"><tt>ftruncate()</tt></a> : truncate a file to a specified length.

<li><p>
<!--<a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/stat.html" target="_blank"><tt>stat()</tt></a> : get file status-->
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html" target="_blank"><tt>stat()</tt></a> : get file status

</ul>

<hr>

<h2>Files by example</h2>

<p>Here are some examples of using the file API<!--as demonstrated in class, and beyond-->. Background on files and links to the interface specifications are provided below.

<h4>Write a simple array to a file</h4>

<!--<pre class="prettyprint">-->
<pre class="prettyprint linenums">#include &lt;stdio.h>

int main( int argc, char* argv[] )
{
  const size_t len = 100;
  int arr[len];

  // put data in the array
  // ...

  // write the array into a file (error checks ommitted)
  FILE* f = fopen( "myfile", "w" ); 
  fwrite( arr, sizeof(int), len, f );
  fclose( f );

  return 0;
}
</pre>

<h4>Read a simple array from a file</h4>

<!--<pre class="prettyprint">-->
<pre class="prettyprint linenums">#include &lt;stdio.h>

int main( int argc, char* argv[] )
{
  const size_t len = 100;
  int arr[len];

  // read the array from a file (error checks ommitted)
  FILE* f = fopen( "myfile", "r" ); 
  fread( arr, sizeof(int), len, f );
  fclose( f );

  // use the array
  // ...

  return 0;
}
</pre>


<h4>Write an array of structs to a file, then read it back</h4>

<!--<pre class="prettyprint">-->
<pre class="prettyprint linenums">#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>

typedef  struct 
{
  int x,y,z;
} point3d_t;

int main( int argc, char* argv[] )
{
  const size_t len = atoi(argv[1]);
  
  // array of points to write out
  point3d_t wpts[len];
  
  // fill with random points
  for( size_t i=0; i&lt;len; i++ )
    {
      wpts[i].x = rand() % 100;
      wpts[i].y = rand() % 100;
      wpts[i].z = rand() % 100;
    }
  
  // write the struct to a file (error checks ommitted)
  FILE* f1 = fopen( argv[2], "w" ); 
  fwrite( wpts, sizeof(point3d_t), len, f1 );
  fclose( f1 );
  
  // array of points to read in from the same file
  point3d_t rpts[len];
  
  // read the array from a file (error checks ommitted)
  FILE* f2 = fopen( argv[2], "r" ); 
  fread( rpts, sizeof(point3d_t), len, f2 );
  fclose( f2 );
  
  if( memcmp( wpts, rpts, len * sizeof(rpts[0]) ) != 0 )
    puts( "Arrays differ" );
  else
    puts( "Arrays match" );
	 
  return 0;
}
</pre>

<!--<div class="steps">-->
<h4>Saving and loading an image structure, with error checking</h4>

<p>This example shows the use of a simple file format that uses a short "header" to describe the file 
contents, so that an object of unknown size can be loaded.

<p>Make sure you understand this example in detail. It combines elements from the examples above into 
a simple but realistic implementation of a file format.
<!--</div>-->

<!--<pre class="prettyprint">-->
<pre class="prettyprint linenums">
/* saves an image to the filesytem using the file format:
   [ cols | rows | pixels ]
   where:
     cols is a uint32_t indicating image width
     rows is a uint32_t indicating image height
     pixels is cols * rows of uint8_ts indicating pixel grey levels
*/
int img_save( const img_t* img, const char* filename )
{
  // validate the parameters 
  assert( img );
  assert( img->data );
  assert( filename );

  // open the file for writing
  FILE* f = fopen( filename, "w" ); 
  if( f == NULL )
    {
      puts( "Failed to open image file for writing" );
      return 1;
    }

  // write the image dimensions header
  uint32_t hdr[2];
  hdr[0] = img->cols;
  hdr[1] = img->rows;

  if( fwrite( hdr, sizeof(uint32_t), 2, f ) != 2 )
    {
      puts( "Failed to write image header" );
      return 2;
    }    
  
  const size_t len = img->cols * img->rows;
  
  if( fwrite( img->data, sizeof(uint8_t), len, f ) != len )
    {
      puts( "Failed to write image pixels" );
      return 3;
    }    

  // always close a file
  fclose( f );
  return 0;
}

/* loads an img_t from the filesystem using the same 
   format as img_save().

   Warning: any existing pixel data in img->data is not free()d.
*/
int img_load( img_t* img, const char* filename )
{
  // validate the parameters
  assert( img );
  assert( filename );

  // open the file for reading
  FILE* f = fopen( filename, "r" ); 
  if( f == NULL )
    {
      puts( "Failed to open image file for reading" );
      return 1;
    }
    
  // read the image dimensions header:
  uint32_t hdr[2];
  
  if( fread( hdr, sizeof(uint32_t), 2, f ) != 2 )
    {
      puts( "Failed to read image header" );
      return 2;
    }    
  
  img->cols = hdr[0];
  img->rows = hdr[1];

  // helpful debug:
  // printf( "read header: %u cols %u rows\n", 
  //	  img->cols, img->rows );
  
  // allocate array for pixels now we know the size
  const size_t len = img->cols * img->rows; 
  img->data = malloc( len * sizeof(uint8_t) );
  assert( img->data );

  // read pixel data into the pixel array
  if( fread( img->data, sizeof(uint8_t), len, f ) != len ) 
     { 
       puts( "Failed to read image pixels" ); 
       return 3;
     }    
 
  // always close a file
  fclose( f );
  return 0;
}
</pre>

<p>Usage:

<pre class="prettyprint linenums">img_t img;
img_load( &img, "before.img" );

image_frobinate( img ); // manipulate the image somehow

img_save( &img, "after.img" );
</pre>



<div class="task">
<h2>Task 1: Serialize an array of integers to a binary-format file</h2>

<p>Extend the functionality of your integer array from Lab 5 to support saving and loading arrays from the filesystem in a binary format.

<h2>Instructions</h2>
<div class="steps">
<p>Use the header file <tt>intarr.h</tt> you have fetched for this lab. 
It contains these new function declarations:
</div>

<pre class="prettyprint">
/* LAB 6 TASK 1 */

/*
  Save the entire array ia into a file called 'filename' in a binary
  file format that can be loaded by intarr_load_binary(). Returns
  zero on success, or a non-zero error code on failure. Arrays of
  length 0 should produce an output file containing an empty array.

  Make sure you validate the parameters before you use them.
*/
int intarr_save_binary( intarr_t* ia, const char* filename );

/*
  Load a new array from the file called 'filename', that was
  previously saved using intarr_save_binary(). Returns a pointer to a
  newly-allocated intarr_t on success, or NULL on failure.

  Make sure you validate the parameter before you use it.
*/
intarr_t* intarr_load_binary( const char* filename );
</pre>


<h3>Requirements</h3>
<div class="req">
<p><ol>
<li>Add and commit a single C source file called "t1.c" containing implementations of these two functions.</li>
<li>The file must include the <!--<a href="http://www.cs.sfu.ca/~vaughan/127/intarr.h" target="_blank">-->
"intarr.h" header file.
<li>Your code for this task may call any other functions declared in "intarr.h" and implemented as part 
of Lab 5. Your code will be linked against the grading robot's reference implementation of all the tasks 
of Lab 5 for testing, so make sure the file "t1.c" you submit does not contain the implementation of any
of the tasks (functions) of Lab 5.</li>
<li>To test your code for this Task 1, create your own "testDriver.c" (which you do not have
to submit) and use your own implementation of the tasks (functions) of Lab 5, i.e., "intarr.c".  
<!--Note that you do not need to have completed all of Lab 5 to do this Lab 6 task, 
but seek help right away if you have not completed intarr_create() at least.--></li>
<li><i>Performance hint: calls to fwrite() are relatively expensive. Try to use as few as you can.</i>
</div>

<h3>Submission</h3>

<p>Commit the single file "t1.c" to your repo in the Lab 6 directory.

</div>

<div class="task">
<h2>Task 2: Serialize an array of integers to a JSON text-format file</h2>

<p>Extend the functionality of your integer array from Lab 5 to support saving and loading arrays from the filesystem in JSON, a common human- and machine-readable text format.

<p>Sometimes it is useful for humans to be able to read your stored data, or to import your data into another program that does not understand your binary format. The most readable, portable XDR format is plain text. A popular syntax for text files is 
<a href="http://json.org" target="_blank">JSON (JavaScript Object Notation)</a>, which, as the name suggests, was originally an XDR format for web programs. It is easier to use and less verbose than the also-popular 
<a href="http://en.wikipedia.org/wiki/XML" target="_blank">Extensible Markup Language (XML)</a> and more expressive than the bare-bones
<a href="http://en.wikipedia.org/wiki/Comma-separated_values" target="_blank">Comma-Separated Values (CSV)</a> formats you may have seen.

<p>The down side of text formats is that they are:

<ol>
<li>inefficient in
space, since e.g. a four-byte integer (int32_t) could require up to 11
bytes to represent its minimum value of -2147483648 as a decimal string; 
<li> inefficent in
time, since parsing the text file to convert it back into a binary
format is much more expensive than loading a binary file.
</ol>

<p>The standard library has two functions that can be very helpful for rendering text into files:

<ul>
<li>
<!--<a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/fprintf.html" target="_blank"><tt>fprintf()</tt></a>-->
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html" target="_blank"><tt>fprintf()</tt></a>

<li>
<!--<a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/fscanf.html" target="_blank"><tt>fscanf()</tt></a>-->
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fscanf.html" target="_blank"><tt>fscanf()</tt></a>
</ul>

<p>They work just like the familiar <tt>printf()</tt> and <tt>scanf()</tt> but read to and write from <tt>FILE*</tt> objects instead of standard input and standard output. You should probably use these to solve this task.

<p>Notice from those man pages that another pair of functions <tt>snprintf()</tt> and <tt>sscanf()</tt> is also available to print and scan from C strings too. (<tt>sprintf()</tt> exists, but the lack of array length checking means this is not safe or secure to use. Always use <tt>snprintf()</tt>).

<p>The header file "intarr.h" also contains these new function declarations:

<pre class="prettyprint">
/* LAB 6 TASK 2 */

/*
  Save the entire array ia into a file called 'filename' in a JSON
  text file array file format that can be loaded by
  intarr_load_json(). Returns zero on success, or a non-zero error
  code on failure. Arrays of length 0 should produce an output file
  containing an empty array.

  Make sure you validate the parameters before you use them.
  
  The JSON output should be human-readable.

  Examples:

  The following line is a valid JSON array:
  [ 100, 200, 300 ]
  
  The following lines are a valid JSON array:
  [ 
   100, 
   200, 
   300 
  ]
*/
int intarr_save_json( intarr_t* ia, const char* filename );


/*
  Load a new array from the file called 'filename', that was
  previously saved using intarr_save_json(). The file may contain an array
  of length 0. Returns a pointer to a newly-allocated intarr_t on
  success (even if that array has length 0), or NULL on failure.

  Make sure you validate the parameter before you use it.
*/
intarr_t* intarr_load_json( const char* filename );
</pre>


<h3>Requirements</h3>
<div class="req">
<p><ol>
<li>Add and commit a single C source file called "t2.c" containing implementations of these two functions. 
<li>The other requirements of Task 1 apply.
<li><i>Hint: you should NOT create a single huge string in memory and write it out in one call to fwrite(). The string could require a huge amount of memory when your array is large. Since you chose an inefficient text format, 
you're not optimizing for speed so don't worry about using many calls to fwrite().</i>
</div>

<h3>Submission</h3>

<p>Commit the single file "t2.c" to your repo in the Lab 6 directory.

</div>

<hr>
<div class="labends">
Lab 6 complete. <a href="../../">Back to the course web page</a>.
</div>
</body>
</html>
