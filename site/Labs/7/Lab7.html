<!DOCTYPE html>
<!-- saved from url=(0057)http://www.cs.sfu.ca/CourseCentral/125/bbart/1/index.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
    <meta charset="utf-8">
    <title>CMPT127 Lab 7</title>
    
     <!-- Please don't change internal links and refs to absolute paths -->
    <link rel="stylesheet" href="../css/style.css">
	
	<!--<link rel="icon" href="../favicon.ico" type="image/x-icon"> NOT FOUND -->
	<link rel="icon" href="../img/favicon.ico" type="image/x-icon">    
    
	<!-- Code syntax highlighting -->
	<!--<script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"> NOT FOUND -->
	<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

    <!-- force printing a line number in every line when prettyprinting -->
    <style>
        .prettyprint ol.linenums > li { list-style-type: decimal; }
    </style>
</head>


<!--
Minor changes: Anne Lavergne 2017 + 2019
-->

<body>

<div class="lab">
<h1>Lab 7: Testing and Lists</h1>

<h4>Testing code for correctness; linked lists</h4>

<div id="floatingCornerLeft">
<a href="http://books.google.ca/books?id=RFJiAgAACAAJ&dq=%22Computer+lieben+Frauen&hl=en&sa=X&ei=H9SoUuCrBI_YoASa2oCADQ&ved=0CEcQ6AEwAA" target="_blank"><img src="../img/balloon0.jpg" height="150"></a>
</div>

<div id="floatingCornerRight">
<a href="http://books.google.ca/books?id=RFJiAgAACAAJ&dq=%22Computer+lieben+Frauen&hl=en&sa=X&ei=H9SoUuCrBI_YoASa2oCADQ&ved=0CEcQ6AEwAA" target="_blank"><img src="../img/balloon1.jpg" height="150"></a>
</div>


</p><h3>Goals</h3>
<p>This lab provides:

<ol>
<li>practice writing tests to determine the correctness of functions.
<li>implementing operations on linked lists
<li>write an efficient list sort function 
</ol>


<h3>Setup</h3>
<div class="steps">
<p>Note that these instructions no longer include all steps. You
should know how to do these things by now. If in doubt, refer to
previous lab instructions.</p>

<p>In the terminal:
<ol>
	<li>Fetch the <a href="7.zip" target="_blank">new material</a> for Lab 7 and save it into your local repo.</li>

<!--<li>Fetch the new material for Lab 7, stored in a <a href="http://en.wikipedia.org/wiki/Tar_(computing)" target="_blank">compressed tarball</a>:
<pre>$ wget http://www.cs.sfu.ca/~vaughan/127/lab7.tgz</pre>
<li>Expand the archive into the working directory:
<pre>$ tar xzvf lab7.tgz</pre>--> 

	<li>Expand it into your local repo. This will create the directory '7' containing the files you need.</li>
	<li>Add the new directory to your repo with <pre>$ git add 7</pre> then make '7' your working directory.</li>
<br>
</ol>
</div>	


<p>Make sure you read and understand the Guide section below. Linked lists have been described in CMPT 125, but it doesn't hurt to see them again.</p> 

<h3>Drawing - A tool for thinking</h3>

<p>Drawing diagrams like those below is very helpful before writing code that modifies lists. In general, sketching machines - including code - is a tool for thinking: even if you think you know what you are doing, drawing out the operations is a concrete test of your understanding. Even very experienced people with great intuition use drawings for thinking.

<p><a href="http://en.wikipedia.org/wiki/Leonardo_da_Vinci#Observation_and_invention:" target="_blank"><img src="../img/Lab7/leonardo.jpg"></a>
<p>Figure 1 - Diagram by Leonardo da Vinci</p>

<a href="http://en.wikipedia.org/wiki/Feynman_diagram" target="_blank"><img width=400 src="../img/Lab7/feynman.png"></a>
<p>Figure 2 - Feynman Diagram</p>

<hr>

<h2>Guide: Linked Lists</h2>

<p><b>Linked lists</b> are data structures that contain a sequence of data elements, like arrays, but with different dynamic properties.

<p>The key idea in the linked list is to use a simple data structure to store each data element along with a pointer to the next element in the list. The end of the list is denoted by NULL next-pointer.

<p>Our implementation is typical in that it uses a second data structure called a <b>header</b> to store pointers to the first (head) and last (tail) elements in the list. 

<p>The list is assembled as follows:

<p>First a <tt>list_t</tt> structure is allocated on the heap, with its head- and tail-pointers set to NULL, representing an empty list.

<p><img src="../img/Lab7/list 1.png">

<p>To insert the first value into the list, a new <tt>element_t</tt>  is allocated on the heap, the value is stored in it, and the header's head- and tail-pointers are both set to point to it. The first element's next-pointer is NULL to indicate it is the last element in the list.

<p><img src="../img/Lab7/list 2.png">

<p>When a subsequent element is added, the next-pointer of the tail element and the tail-pointer of the header are both changed to the address of the new element:


<p><img src="../img/Lab7/list 3.png">

<p>One more addition using the same mechanism. Notice that the tail element always has its next-pointer set to NULL.

<p><img src="../img/Lab7/list 4.png">


<P>Notice that the head- and tail-pointers can be used to add elements to the beginning or end of the list in constant time (O(1)), in contrast to extending native C arrays which in general takes time proportional to the number of elements in the array, i.e. O(n).

<p>Also, given a pointer to any element, an element can be inserted <i>after it</i> in constant time.

<p>However, looking up a list element by its position in the list, like an array index, takes time proportional to its position in the list, i.e. O(n). List elements are therefore best accessed in order, since accessing the next element takes constant time.

<p>A common variant is the <b>double-linked list</b> in which every element contains a previous-pointer in addition to the next-pointer. Double-linked lists can be traversed forwards and backwards, at the cost of a little more storage space per element.

<p>It is important to note that while lists have good theoretical resizing properties, iterating over elements in a list can be much slower than iterating over C arrays due to the cache behaviour of current computer architectures. C arrays guarantee that elements are contiguous in memory, making very effective use of the cache. We will talk about cache behaviour later in labs.

<div class="task">
<h2>Tasks 1..5</h2>

<p>The compressed file you downloaded contains a header file <tt>list.h</tt> that contains an
interface specification for a linked-list-of-integers data structure. 
See the Guide above for notes on linked lists. Six slightly different implementations are provided, 
in files <tt>tN.c</tt> where N = [1..5]. The file <tt>main.c</tt> contains a very weak test program 
for the linked list code.

<p>The <tt>Makefile</tt> will build programs t1 through t5, each linking the same <tt>main.c</tt> with one of the list implementation C files. 

<p>Build each program by naming it as your 'make' target, e.g.

<pre>$ make t1
$ make t5
</pre>

<p>The above two make commands will each create an executable 't1' and 't5'. You can also build all programs by using the following command:

<pre>$ make all</pre>

<p>Running the resulting programs, you will see that every one passes the test in <tt>main.c</tt>.
 At this point the beginner might relax and load up Minecraft. 
 But we have left blissful ignorance behind us. We are suspicious. In fact all of these implementations contain bugs.

<p>Your task is to extend <tt>main.c</tt> to thoroughly test the list implementations. 
Your program must reliably distinguish all these faulty implementations from a correct one.

<p>The grading robot tests work as follows: Your <tt>main.c</tt> will be
compiled with each of tN.c as well as a bug-free version (not supplied
to you). You pass Task N if your program consistently returns 1 when
it runs the buggy code, but 0 when it runs the bug-free code. Remember:
returning 1 means an error has occured during the execution of your program 
while returning 0 means that your program successfully executed.

<h3>Requirements</h3>
<div class="req">
<p>
<ol>
<li>A program built from your <tt>main.c</tt> and linked against any implementation of the functions in <tt>list.h</tt> 
must return 0 if the functions are bug-free, or 1 if they contain one or more bugs.
<!-- <li>The server tests will be in a randomized order, so do not rely on the number.-->
<li>Preferably, your program should not crash or halt on <tt>assert()</tt>. 
But a crash (e.g., segmentation fault) or assertion will be recorded as indicating the code contained bugs, just like with the grading robot. 
<li>Preferably, print an explanatory error message on stdout describing the problem you discovered.
<li>You may produce (a sensible amount) of other text output on stdout or stderr if you wish.
<li>The grading robot will not test your text output: only the return value. Try to make the text output helpful for yourself or an instructor/TA helping you.
</ol>
</div>

<h3>Submission</h3>

<p>Commit a revised version of <tt>main.c</tt>. This will be linked against each of the buggy list implementations <tt>tN.c</tt> 
used by the grading robot in the same way you did locally. The grading robot also has a correct version of the code. 
Your program should return zero when linked to the correct code, and non-zero when linked to any of the buggy versions.


<p>Task N will be passed if your program can reliably distinguish between a buggy and correct version of the code. To test reliability, your test program will be run several times. It must correctly detect bugs or no-bugs every time.

<!--
<div class="steps">
<p>Important: If you strongly suspect a bug in the reference code, perhaps because your test program reveals one, let Vaughan know right away.
</div>
-->

<!--
<h3>A useful thing to know about the behaviour of the standard library</h3>

<p>Recall that in <tt>foo_t* p = malloc( sizeof(foo_t) );</tt>, <tt>malloc()</tt> returns the base address of (i.e. a pointer to) a chunk of memory on the heap the size of <tt>foo_t</tt>. 
When you are finished with the memory, you return it to the system with <tt>free(p);</tt>. Now, if you immediately <tt>malloc( sizeof(foo_t))</tt> again, <tt>malloc()</tt> is very likely to give you <i>the exact same piece of memory back again</i>. This is not required by the specification, but it gives very good performance and most implementations of <tt>malloc()</tt> will show this behaviour.

<p>This fact is very handy for debugging, since we can exploit the fact that the contents of the memory chunk will probably be unchanged between the <tt>free()</tt> and <tt>malloc()</tt>. For example, if you set the entire contents of the memory chunk to be non-zero before you free it, it will not contain any NULL pointers when you get it back again. You can also set data fields to particular memorable values. You can check for them later and you might infer that these fields were not set by an intialization function.

<p><b>Hint:</b> think about how you might use this strategy to spot bugs.
-->

</div>

<div class="task">
<h2>Task 6</h2>

<h3>Requirements</h3>
<div class="req">
<ol>
<li>Commit a new file called <tt>list.c</tt> containing correct
implementations of all the functions described in <tt>list.h</tt>.
<li>You may use any piece(s) of the supplied code, or write your own.
<li>Your code should pass all your tests (i.e., the <tt>main.c</tt> you extended in Tasks 1 to 5, and the grading robot's tests.
</ol>
</div>

<h3>Submission</h3>

<p>Commit a single C file called <tt>list.c</tt>.


</div>

<div class="task">
<h2>Task 7</h2>

<p>Write a function that sorts an instance of our linked list of integers from smallest to largest value. 

<h3>Requirements</h3>
<div class="req">
<ol>
<li>Commit a new file called <tt>sort.c</tt> containing at least the function <tt>list_sort()</tt>
<li>Your file must not contain a <tt>main()</tt> function or change the structures in <tt>list.h</tt>.
<li>The function must #include the <tt>list.h</tt> header...
<li> ... and be consistent with the function declaration:

<pre class="prettyprint"> void list_sort( list_t* list ); </pre>

<li><b>Use <a href="http://en.wikipedia.org/wiki/Sorting_algorithm" target="_blank">an efficient algorithm</a>, i.e., an algorithm that sorts in O(n log n)!</b>
<li> Did you read requirement 5?
<li> Do <b>not</b> turn your list into an array, sort it, then turn it back into a list. That's cheating.
</ol>
</div>

<h3>Submission</h3>

<p>Commit a single C file called <tt>sort.c</tt>.

</div>

<hr>
<div class="labends">
Lab 7 complete. <a href="../../">Back to the course web page</a>.
</div>
</body>
</html>